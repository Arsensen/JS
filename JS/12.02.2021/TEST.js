
var obj = {
  prop: 10,
  fnc: function() {
    return this.prop;
  }
};

console.log( obj.fnc() );
var fnc = obj.fnc;
console.log( fnc() ); //при присвоении переменной var fnc = функции obj.fnc, функция var fnc получает окружение глобального объекта, у которого нет свойства prop


//=-----------=------------=------------=------------=

var x = 1;

console.log(x);

if (true) {
  var x = 2;
  console.log(x);
}

console.log(x); //var x в блоке if переписывает значение, поскольку его область видимости не ограничена блочной видимостью, только функциональной


//=-----------=------------=------------=------------=


var a = 1;

function foo() {
  console.log(a);
}

function bar() {
  var a = 2;
  foo();
}

bar(); //Scope функции всегда зависит от места создания функции, а не места вызова


//=-----------=------------=------------=------------=

function test() {
  foo();
  bar();
  var foo = function () {
    alert("FOO");
  }
  function bar() {
    alert("BAR");
  }
}
test(); //foo() выдаст ошибку, потому что Function Expression становятся доступны только после их инициализации в коде; alert браузерный метод


//=-----------=------------=------------=------------=

var a = {key: 'foo'};
var b = {key: 'bar'};
var c = {};

c[a] = 123;
c[b] = 345; 

console.log(c[a], c[b], c); //при создании свойств c[a] и c[b] произойдет приведение ключа к строковому значению, в обоих случаях это будет [object Object], потому один ключ перезапишет другой

//=-----------=------------=------------=------------=


var a = { b: 1 },
    c = Object.create(a);

//c = { z : 3 }

console.log(c.b); // c наследует от a, потому получает доступ к а.b
delete c.b;
console.log(c.b); // у c нет свойства b, потому удаление ничего не делает, c по-прежнему имеет доступ к свойству a.b
delete a.b;
console.log(c.b); // теперь свойство b удаляется уже из а
a.z = 2;
console.log(c.z); // с имеет доступ к свойству z, так как с наследует от а
c.z = 3;
console.log(a.z); // c.z создало новое свойство в объекте c, но никак не повлияло на свойство a

//=-----------=------------=------------=------------=


console.log(4 > 2 > 3); // результат 4>2 вернет true -> true>3 - false
console.log(1 > 2 > 3); // 1>2 - false -> false>3 - false
console.log(3 < 2 < 1); // 3<2 - false -> false<1 - true
console.log('b' + 'a' + +'a'); // унарный плюс перед последней а выполнит приведение строкового "а" в число равное NaN 



//=-----------=------------=------------=------------=


Promise.reject('a')
    .catch(p=>p+'b') // отлавливает отклоненный промис, выполняет a + b
    .catch(p=>p+'с') // пропускается, поскольку первый catch возвращает не ошибку
    .then(p=>p+'d') // ab + d
    .finally(p=>p+'e') // undefined + 'e'    
    .then(p=>console.log(p)); // abd

console.log('f'); //выполниться раньше промиса, так как операция синхроннная




//=-----------=------------=------------=------------=


var a = 'hello';
function b() {
  console.log(a); // при входе в функцию происходит поднятие локального var a, которому присваивается значение undefined 
  var a = 'world'; 
  console.log(a); // a уже присвоено новое значение
}
b();


//=-----------=------------=------------=------------=


var a = 'hello';
function b() {
  if (false) {
    var a = 'world'
  } else {
    var b = 'man'
  }
  console.log(b);
  console.log(a); // при входе в функцию происходит поднятие var a = undefined и var b = undefined, поскольку блоки if...else не ограничивают видимость var 
}
b();


//=-----------=------------=------------=------------=



var obj = {
a: function() {
  console.log(this.prop);
},
prop: 5
};

obj.a.prop = 2;
obj.a(); // для метода а this является объект в котором он создан, потому он будет ссылаться не на внутренний объект функции, куда записан prop=2
var fn = obj.a; // в переменную fn копируется фунуция из а

prop = 5000;
fn(); // fn ссылается на глобальный объект в который было записано prop=5000



//=-----------=------------=------------=------------=


function f2() {
  let i = 0;

  return function() {
    return ++i
  }
}

var f = f2();

console.log( f() ); //благодаря замыканию у функции f есть доступ к переменной i
console.log( f() );
console.log( f() );

//=-----------=------------=------------=------------=

class First {
  constructor() {
    this.a = 2;
  }

  a: () => {} // свойства класса создаются через присваивание = или как метод, а не :
}

class Second extends First {
  constructor (a) {                                         
    super(a)
  }
}

var second = new Second(4);
console.log(second);
console.log(second.a()) // конструктор родительского класса создал в объекте second свойство a === 2, потому обращение к a найдет 2, а не функцию 

//=-----------=------------=------------=------------=

var obj = {
  a: 5,
  b: {
    c: 10
  }
};

obj.__proto__ = {
  a: 10,
  b: {
    c: 20
  }
};

delete obj.a;
console.log(obj.a); // собственное свойство a удаляется, obj.a находит свойство родительского объекта = 10

delete obj.a;
console.log(obj.a); // повторное удаление уже ничего не делает, свойство родительского объекта снова находится = 10

delete obj.b;
console.log(obj.b.c); // удалено собственное свойство b, потому поиск продолжается в родителе, где с = 20

delete obj.b.c;
console.log(obj.b.c); // доступ к с получается по ссылке через объект b, потому свойство c можно удалить 

//=-----------=------------=------------=------------=


var a = 1;
function b() {
  a = 10;
  return;
  function a(){}
}

b();
console.log(a); // у function declaration происходит поднятие при входе в функцию b, потому а становится локальной внутри b и не влияет на внешнюю а

